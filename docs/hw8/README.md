### Задача 1
До текущего момента сервисы bot и scrapper общались строго синхронно по протоколу HTTP.

Но что если в какой-то момент bot станет недоступен и наш планировщик не сможет отправить уведомление?

Для таких ситуаций часто предпочтительным оказывается асинхронный способ общения.

Перед тем как настраивать отправку/получение сообщений нам нужно создать очередь локально.

* Добавьте в compose.yml новый сервис на базе kafka и zookeeper.
* Для хранения данных создайте новый именованный volume

Проверьте, что у вас есть доступ до Kafka через IDEA (плагин Kafka) или Offset Explorer.

### Задача 2
После того как у нас появилась зависимость в виде Kafka, мы можем начать отправлять/получать сообщения.

В модулях scrapper/bot уже есть необходимые зависимости для использования Kafka.

Объявите класс KafkaConfiguration и создайте [необходимые бины для работы очереди](https://docs.spring.io/spring-kafka/reference/quick-tour.html).

Все имена должны передаваться из конфигурационного файла, т.е. через ApplicationConfig.

### Задача 3
Напишите отдельный класс-сервис для отправки сообщений в очередь:

    @Service
    @RequiredArgsConstructor
    public class ScrapperQueueProducer {
        public void send(LinkUpdate update) {
            // TODO
        }
    }
Для отправки следует использовать KafkaTemplate.

### Задача 4
Теперь у нас есть 2 способа отправить уведомление в bot.

* Сделайте абстракцию отправки уведомлений в виде нового сервиса
* В ApplicationConfig добавьте новое поле boolean useQueue
* В зависимости от значения новый сервис должен отправлять сообщения или в очередь через ScrapperQueueProducer или по HTTP через BotClient

### Задача 5
Пришло время добавить обработчик обновлений.

Повторите аналогичные действия по настройке KafkaConfiguration, но уже в модуле bot.

Создайте слушателя очереди при помощи [@KafkaListener](https://docs.spring.io/spring-kafka/reference/kafka/receiving-messages/listener-annotation.html):

    @KafkaListener(topics = "${app.scrapper-topic.name}")
    public void listen(LinkUpdate update) { ... }

Сделайте абстракцию обработки уведомлений в виде нового сервиса, т.е. не должно быть дублирования кода между обработкой HTTP-уведомлений и уведомлений, полученных через очередь.

### Задача 6
Бывают ситуации, когда нельзя обработать сообщение. Самые частые причины это:

* недоступность внешней системы
* невалидное сообщение

В первом случае мы можем попробовать retry. Но повтор обработки никак не поможет со вторым. Поэтому обычно вместо повторов используют вспомогательную очередь для "плохих" сообщений.

Реализуйте шаблон Dead Letter Queue для вашей очереди.

Для этого в модуле bot создайте новую очередь с суффиксом _dlq, и в случае ошибки обработки отправляйте сообщение в эту очередь.
